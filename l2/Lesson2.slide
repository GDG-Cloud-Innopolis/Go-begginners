Go Beginners Innopolis 
Занятие 2: Управление потоком, Коллекции
13 Feb 2020
Tags: go, innopolis

Emil Sharifullin
Senior Software Engineer, SKB Kontur
iam@litleleprikon.me
@litleleprikon

* В прошлых сериях

- Какие есть численные типы в Go?
- Какие операции можно производить с булевыми переменными?
- Чем переменная отличается от константы?

* Тур по Go

.link https://tour.golang.org https://tour.golang.org
.link https://go-tour-ru-ru.appspot.com https://go-tour-ru-ru.appspot.com

Интерактиынй учебник по го с примерами и задачками

* Управление потоком выполнения программы

* Жизнь без циклов

.play src/flow/for/indian/main.go

* Цикл for

Оператор *for* даёт возможность повторять список инструкций (блок) определённое количество раз. Давайте перепишем предыдущую программу, используя оператор *for*:

.play src/flow/for/first/main.go

Условие делится на три части:

- В начале выполнения цикла выполняется первая часть условия
- Если условие во второй части истинно, то цикл продолжается
- Каждую итерацию цикла выполняется код из третьей части

* Другой вид цикла for

.play src/flow/for/second/main.go

* Условный оператор if

Оператор *if* аналогичен оператору *for* в том, что он выполняет блок в зависимости от условия. Оператор также может иметь необязательную *else* часть. Если условие истинно, выполняется блок, расположенный после условия, иначе же этот блок пропускается и выполняется блок *else*, если он присутствует.

.play src/flow/if/first/main.go


* Цикл for не всегда удобен

.play src/flow/switch/if/main.go

* Оператор switch

.play src/flow/switch/first/main.go

* Оператор switch

Переключатель начинается с ключевого слова *switch*, за которым следует выражение (в нашем случае *i*) и серия возможных значений (*case*). Значение выражения по очереди сравнивается с выражениями, следующими после ключевого слова *case*. Если они оказываются равны, то выполняется действие, описанное после *:*.

Как и условия, обход возможных значений осуществляется сверху вниз, и выбирается первое значение, которое сошлось с выражением. Переключатель также поддерживает действие по умолчанию, которое будет выполнено в случае, если не подошло ни одно из возможных значений (напоминает *else* в операторе *if*).

* Другая форма switch

.play src/flow/switch/second/main.go


* Коллекции

* Массивы

Массив — это нумерованная последовательность элементов одного типа с фиксированной длиной. В Go они выглядят так:

.play src/collections/arrays/first/main.go

x[4] = 100 должно читаться как «присвоить пятому элементу массива x значение 100». Может показаться странным то, что x[4] является пятым элементом массива, а не четвертым, но, как и строки, массивы нумеруются с нуля. Доступ к элементам массива выглядит так же, как у строк. Вместо fmt.Println(x) мы можем написать fmt.Println(x[4]) и в результате будет выведено 100.

* Итерация по массиву

.play src/collections/arrays/second/main.go

- сперва мы создаем массив длины 5 и заполняем его
- затем мы в цикле считаем общее количество баллов
- и в конце мы делим общую сумму баллов на количество элементов

* Другой способ итерации по массиву

.play src/collections/arrays/third/main.go

- массивы можно инициализировать значениями в месте их определения
- *range* позволяет итерироваться по коллекциям
- типы можно конвертировать
- если *i* не будет использован, компилятор выкинет ошибку

* В итоге

.play src/collections/arrays/fourth/main.go

* Срезы

Срез это часть массива. Как и массивы, срезы индексируются и имеют длину. В отличии от массивов их длину можно изменить. Вот пример среза:

    var x []float64

Единственное отличие объявления среза от объявления массива — отсутствие указания длины в квадратных скобках. В нашем случае x будет иметь длину 0.

Срез создается встроенной функцией make:

    x := make([]float64, 5)

Этот код создаст срез, который связан с массивом типа float64, длиной 5. Срезы всегда связаны с каким-нибудь массивом. Они не могут стать больше чем массив, а вот меньше — пожалуйста. Функция make принимает и третий параметр:

    x := make([]float64, 5, 10)

* Срезы

Другой способ создать срез — использовать выражение [low : high]:

    arr := [5]float64{1,2,3,4,5}
    x := arr[0:5]

.image img/01.png

low - это позиция, с которой будет начинаться срез, а high - это позиция, где он закончится. Например: arr[0:5] вернет [1,2,3,4,5], arr[1:4] вернет [2,3,4].

Для удобства мы также можем опустить low, high или и то, и другое. arr[0:] это то же самое что arr[0:len(arr)], arr[:5] то же самое что arr[0:5] и arr[:] то же самое что arr[0:len(arr)].

* Функции срезов - append

Функция *append* создает новый срез из уже существующего (первый аргумент) и добавляет к нему все следующие аргументы.

.play src/collections/slices/append/main.go

После выполнения программы slice1 будет содержать [1,2,3], а slice2 — [1,2,3,4,5].

* Функции срезов - copy

Функция *copy* копирует элементы одного среза в другой срез

.play src/collections/slices/copy/main.go

После выполнения этой программы slice1 будет содержать [1,2,3], а slice2 — [1,2]. Содержимое slice1 копируется в slice2, но поскольку в slice2 есть место только для двух элементов, то только два первых элемента slice1 будут скопированы.

* Словарь | хэш таблица | map | ассоциативный массив

Карта (также известна как ассоциативный массив или словарь) — это неупорядоченная коллекция пар вида ключ-значение. Пример:

    var x map[string]int

Карта представляется в связке с ключевым словом map, следующим за ним типом ключа в скобках и типом значения после скобок. Читается это следующим образом: «x — это карта string-ов для int-ов».

Подобно массивам и срезам, к элементам карт можно обратиться с помощью скобок. Запустим следующую программу:

.play src/collections/maps/init_fail/main.go

* Инициализация

Проблема нашей программы в том, что карта должна быть инициализирована перед тем, как будет использована. Надо написать так:

.play src/collections/maps/init/main.go

Если выполнить эту программу, то вы должны увидеть 10. Выражение x["key"] = 10 похоже на те, что использовались при работе с массивами, но ключ тут не число, а строка (потому что в карте указан тип ключа string).

* Словарь и массив

Мы также можем создать карты с ключом типа int:

.play src/collections/maps/int/main.go

Это выглядит очень похоже на массив, но существует несколько различий. Во-первых, длина карты (которую мы можем найти так: len(x)) может измениться, когда мы добавим в нее новый элемент. В самом начале при создании длина 0, после x[1] = 10 она станет равна 1. Во-вторых, карта не является последовательностью. В нашем примере у нас есть элемент x[1], в случае массива должен быть и первый элемент x[0], но в картах это не так.

* Удаление элементов

Также мы можем удалить элементы из карты используя встроенную функцию delete:

.play src/collections/maps/delete/main.go

* Пример

.play src/collections/maps/ex0/main.go

* Отсутствующие значения

Если вы выполните это, то ничего не увидите. Технически карта вернет нулевое значение хранящегося типа (для строк это пустая строка). Несмотря на то, что мы можем проверить нулевое значение с помощью условия (elements["Un"] == ""), в Go есть лучший способ сделать это:

.play src/collections/maps/ex1/main.go

* Проверка наличия значения

Доступ к элементу карты может вернуть два значения вместо одного. Первое значение это результат запроса, второе говорит, был ли запрос успешен. В Go часто встречается такой код:

    if name, ok := elements["Un"]; ok {    
        fmt.Println(name, ok)
    }

* Словарь словарей

Карты часто используются для хранения общей информации. Давайте изменим нашу программу так, чтобы вместо имени элемента хранить какую-нибудь дополнительную информацию о нем. Например его агрегатное состояние:

.play src/collections/maps/ofmaps/main.go

* Задачка

Написать функцию решета Эратосфена, которая находит все простые числа сплоть до заданного

.link https://play.golang.org/p/UeZfvGzBTUb https://play.golang.org/p/UeZfvGzBTUb
.link https://ru.wikipedia.org/wiki/Решето_Эратосфена https://ru.wikipedia.org/wiki/Решето_Эратосфена
.image img/ex0.svg 300 _

* Задачка *

Написать функцию, которая проверяет, что две заданные строки являются анаграммами

.link https://play.golang.org/p/hlwxQM0rHmX https://play.golang.org/p/hlwxQM0rHmX
.link https://ru.wikipedia.org/wiki/Анаграмма https://ru.wikipedia.org/wiki/Анаграмма
.image img/ex1.svg 300 _