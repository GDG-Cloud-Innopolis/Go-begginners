Go Beginners Innopolis 
Занятие 4: Структуры и интерфейсы, Параллельные вычисления
27 Feb 2020
Tags: go, innopolis

Emil Sharifullin
Senior Software Engineer, SKB Kontur
iam@litleleprikon.me
@litleleprikon


* В прошлых сериях

- Как называется ситуация, когда функция, определенная внутри другой функции взаимодействует с переменными "родительской" функции?
- В каких случаях возможно вызвать return без указания возвращаемых значений?
- Что делает оператор defer?
- Что такое указатель?
- Что такое разыменование указателя?

* Структуры и интерфейсы

* Жизнь без структур

Несмотря на то, что вполне можно писать программы на Go используя только встроенные типы, в какой-то момент это станет очень утомительным занятием. Вот пример — программа, которая взаимодействует с фигурами:

.code src/structs/first/main.go /^func distance/,/^}/
.code src/structs/first/main.go /^func rectangleArea/,/^}/
.code src/structs/first/main.go /^func circleArea/,/^}/


* Жизнь без структур

Отслеживание всех переменных мешает нам понять, что делает программа, и наверняка приведет к ошибкам.

.play src/structs/first/main.go /^func main/,/^}/ HL0001

* Представляем вашему вниманию СТРУКТУРЫ

Структура — это тип, содержащий именованные поля. Например, мы можем представить круг таким образом:

    type Circle struct {
        x float64
        y float64
        r float64
    }

* Структуры

Ключевое слово type вводит новый тип. За ним следует имя нового типа (Circle) и ключевое слово struct, которое говорит, что мы определяем структуру и список полей внутри фигурных скобок. Каждое поле имеет имя и тип. Как и с функциями, мы можем объединять поля одного типа:

    type Circle struct {
        x, y, r float64
    }

* Инициализация

Мы можем создать экземпляр нового типа Circle несколькими способами:

    var c Circle

Подобно другим типами данных, будет создана локальная переменная типа *Circle*, чьи поля по умолчанию будут равны нулю (*0* для int, *0.0* для float, *""* для string, *nil* для указателей, …).

.play src/structs/init/first/main.go /^func main/,/^}/

Также, для создания экземпляра можно использовать функцию *new*.

    c := new(Circle)

Это выделит память для всех полей, присвоит каждому из них нулевое значение и вернет указатель (*Circle).


* Инициализация

Часто, при создании структуры мы хотим присвоить полям структуры какие-нибудь значения. Существует два способа сделать это. Первый способ:

    c := Circle{x: 0, y: 0, r: 5}

Или

    c := Circle{
        x: 0,
        y: 0,
        r: 5,
    }

Второй способ — мы можем опустить имена полей, если мы знаем порядок в котором они определены:

    c := Circle{0, 0, 5}

* Поля

Получить доступ к полям можно с помощью оператора *.* (точка):

    fmt.Println(c.x, c.y, c.r)
    c.x = 10
    c.y = 5

Давайте изменим функцию circleArea так, чтобы она использовала структуру Circle:

    func circleArea(c Circle) float64 {
        return math.Pi * c.r*c.r
    }

В функции main у нас будет:

    c := Circle{0, 0, 5}
    fmt.Println(circleArea(c))

* Поля

Очень важно помнить о том, что аргументы в Go всегда копируются. Если мы попытаемся изменить любое поле в функции circleArea, оригинальная переменная не изменится. Именно поэтому мы будем писать функции так:

    func circleArea(c *Circle) float64 {
        return math.Pi * c.r*c.r
    }


И изменим main:

    c := Circle{0, 0, 5}
    fmt.Println(circleArea(&c))

* Методы

    func (c *Circle) area() float64 {
        return math.Pi * c.r*c.r
    }


Между ключевым словом func и именем функции мы добавили «получателя». Получатель похож на параметр — у него есть имя и тип, но объявление функции таким способом позволяет нам вызывать функцию с помощью оператора .:

    fmt.Println(c.area())

* Методы

    type Rectangle struct {
        x1, y1, x2, y2 float64
    }
    func (r *Rectangle) area() float64 {
        l := distance(r.x1, r.y1, r.x1, r.y2)
        w := distance(r.x1, r.y1, r.x2, r.y1)
        return l * w
    }

И в main будет

    r := Rectangle{0, 0, 10, 10}
    fmt.Println(r.area())

* В итоге

.play src/structs/second/main.go /^func main/,/^}/

* Получатели по значению и по указателю

.code src/structs/methods/first/main.go /^type Person/,/^}/
.code src/structs/methods/first/main.go /START PTR OMIT/,/END PTR OMIT/
.code src/structs/methods/first/main.go /START OMIT/,/END OMIT/

* Получатели по значению и по указателю

.play src/structs/methods/first/main.go /^func main/,/^}/

* Встраиваемые типы

Обычно, поля структур представляют отношения принадлежности (включения). Например, у Circle (круга) есть radius (радиус). Предположим, у нас есть структура Person (личность):

.code src/structs/embedding/first/main.go /START PERSON OMIT/,/END PERSON OMIT/


И если мы хотим создать новую структуру Android, то можем сделать так:

    type Android struct {
        Person Person
        Model string
    }

* Встраиваемые типы

Это будет работать, но мы можем захотеть создать другое отношение. Сейчас у андроида «есть» личность, можем ли мы описать отношение андроид «является» личностью? Go поддерживает подобные отношения с помощью встраиваемых типов, также называемых анонимными полями. Выглядят они так:

.code src/structs/embedding/first/main.go /START ANDROID OMIT/,/END ANDROID OMIT/

    a := new(Android)
    a.Person.Talk()

.play src/structs/embedding/first/main.go /^func main/,/^}/

* Интерфейсы

Вы могли заметить, что названия методов для вычисления площади круга и прямоугольника совпадают. Это было сделано не случайно. И в реальной жизни и в программировании отношения могут быть очень похожими. В Go есть способ сделать эти случайные сходства явными с помощью типа называемого интерфейсом. Пример интерфейса для фигуры (Shape):

.code src/interfaces/first/main.go /^type Shape interface/,/^}/

Как и структуры, интерфейсы создаются с помощью ключевого слова type, за которым следует имя интерфейса и ключевое слово interface. Однако, вместо того, чтобы определять поля, мы определяем «множество методов». Множество методов - это список методов, которые будут использоваться для «реализации» интерфейса.

* Интерфейсы

В нашем случае у Rectangle и Circle есть метод area, который возвращает float64, получается они оба реализуют интерфейс Shape. Само по себе это не очень полезно, но мы можем использовать интерфейсы как аргументы в функциях:

.code src/interfaces/first/main.go /^func totalArea/,/^}/
.play src/interfaces/first/main.go /^func main/,/^}/

* Интерфейсы

Интерфейсы также могут быть использованы в качестве полей:

.code src/interfaces/second/main.go /^type MultiShape/,/^}/
.code src/interfaces/second/main.go /START AREA OMIT/,/STOP AREA OMIT/
.play src/interfaces/second/main.go /^func main/,/^}/

* Параллельные вычисления

* Параллельные вычисления

Очень часто, большие приложения состоят из множества небольших подпрограмм. Например, web-сервер принимает запросы от браузера и отправляет HTML страницы в ответ. Каждый такой запрос выполняется как отдельная небольшая программа.

Такой способ идеально подходит для подобных приложений, так как обеспечивает возможность одновременного запуска множества более мелких компонентов (обработки нескольких запросов одновременно, в случае веб-сервера). Одновременное выполнение более чем одной задачи известно как многопоточность. Go имеет богатую функциональность для работы с параллельным программированием, в частности, такие инструменты как горутины и каналы.

* Горутины

Горутина — это функция, которая может работать параллельно с другими функциями. Для создания горутины используется ключевое слово go, за которым следует вызов функции.

.play src/goroutines/first/main.go

* Горутины

Эта программа состоит из двух горутин. Функция main, сама по себе, является горутиной. Вторая горутина создаётся, когда мы вызываем go f(0). Обычно, при вызове функции, программа выполнит все конструкции внутри вызываемой функции, а только потом перейдет к следующей после вызова, строке. С горутиной программа немедленно прейдет к следующей строке, не дожидаясь, пока вызываемая функция завершится. Вот почему здесь присутствует вызов time.Sleep, без него программа завершится еще перед тем, как ей удастся вывести числа.

Горутины очень легкие, мы можем создавать их тысячами. Давайте изменим программу так, чтобы она запускала 10 горутин:

.play src/goroutines/second/main.go /^func main/,/^}/

* Горутины

При запуске вы наверное заметили, что все горутины выполняются последовательно, а не одновременно, как вы того ожидали. Давайте добавим небольшую задержку функции с помощью функции time.Sleep и rand.Intn:

.code src/goroutines/third/main.go /^func f/,/^}/
.play src/goroutines/third/main.go /^func main/,/^}/

* Каналы

Каналы обеспечивают возможность общения нескольких горутин друг с другом, чтобы синхронизировать их выполнение. Вот пример программы с использованием каналов:

.code src/channels/first/main.go /^func pinger/,/^}/
.code src/channels/first/main.go /^func printer/,/^}/

* Каналы

.play src/channels/first/main.go /^func main/,/^}/

Данное использование каналов позволяет синхронизировать две горутины. Когда pinger пытается послать сообщение в канал, он ожидает, пока printer будет готов получить сообщение. Такое поведение называется блокирующим. Давайте добавим ещё одного отправителя сообщений в программу и посмотрим, что будет. Добавим эту функцию:

* Каналы

.code src/channels/second/main.go /^func ponger/,/^}/
.play src/channels/second/main.go /^func main/,/^}/

* Направление каналов

Мы можем задать направление передачи сообщений в канале, сделав его только отправляющим или принимающим. Например, мы можем изменить функцию pinger:

    func pinger(c chan<- string)

и канал c будет только отправлять сообщение. Попытка получить сообщение из канала c вызовет ошибку компилирования. Также мы можем изменить функцию printer:

    func printer(c <-chan string)

Существуют и двунаправленные каналы, которые могут быть переданы в функцию, принимающую только принимающие или отправляющие каналы. Но только отправляющие или принимающие каналы не могут быть переданы в функцию, требующую двунаправленного канала!

* Оператор Select

В языке Go есть специальный оператор select который работает как switch, но для каналов:

.code src/channels/third/main.go /START FIRST/,/STOP FIRST/
.code src/channels/third/main.go /START SECOND/,/STOP SECOND/

* Оператор Select

.play src/channels/third/main.go /START THIRD/,/STOP THIRD/

Эта программа выводит «from 1» каждые 2 секунды и «from 2» каждые 3 секунды. Оператор select выбирает первый готовый канал, и получает сообщение из него, или же передает сообщение через него. Когда готовы несколько каналов, получение сообщения происходит из случайно выбранного готового канала. Если же ни один из каналов не готов, оператор блокирует ход программы до тех пор, пока какой-либо из каналов будет готов к отправке или получению.

* Оператор Select

Обычно select используется для таймеров:

.play src/channels/fourth/main.go /START THIRD/,/STOP THIRD/

time After создаёт канал, по которому посылаем метки времени с заданным интервалом. В данном случае мы не заинтересованы в значениях временных меток, поэтому мы не сохраняем его в переменные.

* Оператор Select

Также мы можем задать команды, которые выполняются по умолчанию, используя конструкцию default:

.play src/channels/fifth/main.go /START THIRD/,/STOP THIRD/

* Буферизированный канал

При инициализации канала можно использовать второй параметр:

    c := make(chan int, 1)

и мы получим буферизированный канал с ёмкостью 1. Обычно каналы работают синхронно - каждая из сторон ждёт, когда другая сможет получить или передать сообщение. Но буферизованный канал работает асинхронно — получение или отправка сообщения не заставляют стороны останавливаться. Но канал теряет пропускную способность, когда он занят, в данном случае, если мы отправим в канал 1 сообщение, то мы не сможем отправить туда ещё одно до тех пор, пока первое не будет получено.

* Задачка

    type Operation interface {
        Values() (float64, float64)
        Solution(float64)
    }

    Calc(add, sub, mul, div <-chan test.Operation, ready chan<- bool

.link https://play.golang.org/p/QeTIqPp3tbF
.image img/qrcode-4.svg 300 _

* Форма для решений

.link https://forms.gle/eA5htEBiQ9AVeCy78
.image img/qrcode-5.svg 300 _

