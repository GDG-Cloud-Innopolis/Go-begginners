Go Beginners Innopolis 
Занятие 3: Функции, Указатели
20 Feb 2020
Tags: go, innopolis

Emil Sharifullin
Senior Software Engineer, SKB Kontur
iam@litleleprikon.me
@litleleprikon

* В прошлых сериях

- За что отвечает блок else?
- Можно ли в switch использовать условия?
- Как обратиться к четвертому элементу массива или среза?
- Чему равна длина среза, созданного таким способом: make([]int, 3, 9)?

* Функции

* Функция

Фу́нкция в программировании — фрагмент программного кода (подпрограмма), к которому можно обратиться из другого места программы. В большинстве случаев с функцией связывается идентификатор, но многие языки допускают и безымянные функции. С именем функции неразрывно связан адрес первой инструкции (оператора), входящей в функцию, которой передаётся управление при обращении к функции. После выполнения функции управление возвращается обратно в адрес возврата — точку программы, где данная функция была вызвана.

.caption [[https://ru.wikipedia.org/wiki/Функция_(программирование)][Википедия]]

Функция является независимой частью кода, связывающей один или несколько входных параметров с одним или несколькими выходными параметрами. Функции (также известные как процедуры и подпрограммы) можно представить как черный ящик:

* Самая "Важная" функция

По умолчанию каждая программа на языке Go должна содержать как минимум одну функцию - функцию main, которая является входной точкой в приложение:

    func main() {}

* Функция среднего

.play src/func/average/main.go

Эта программа вычисляет среднее значение ряда чисел. Поиск среднего значения — основная задача и идеальный кандидат для вынесения в отдельную функцию.

* Функция среднего

Функция average должна взять срез из нескольких float64 и вернуть один float64. Напишем перед функцией main:

    func average(xs []float64) float64 {}

Функция начинается с ключевого слова func, за которым следует имя функции. Аргументы (входы) определяются так: имя тип, имя тип, …. Наша функция имеет один параметр (список оценок) под названием xs. За параметром следует возвращаемый тип. В совокупности аргументы и возвращаемое значение также известны как сигнатура функции.

* Функция среднего

    func average(xs []float64) float64 {    
        total := 0.0
        for _, v := range xs {
            total += v
        }
        return total / float64(len(xs))
    }

    func main() {
        xs := []float64{98,93,77,82,83}
        fmt.Println(average(xs))
    }

* Нюансы

Имена аргументов не обязательно должны совпадать с именами переменных при вызове функции. Например, можно сделать так:

    func main() {
        someOtherName := []float64{98,93,77,82,83}
        fmt.Println(average(someOtherName))
    }

Функции не имеют доступа к области видимости родительской функции, то есть это не сработает:

    func f() {
        fmt.Println(x)
    }
    func main() {
        x := 5
        f()
    }

* Нюансы

Функции выстраиваются в «стек вызовов». Предположим, у нас есть такая программа:

    func main() {
        fmt.Println(f1())
    }
    func f1() int {
        return f2()
    }
    func f2() int {
        return 1
    }

.image img/02.png

Каждая вызываемая функция помещается в стек вызовов, каждый возврат из функции возвращает нас к предыдущей приостановленной функции

* Нюансы

Можно также явно указать имя возвращаемого значения:

    func f2() (r int) {
        r = 1
        return
    }

* Возврат нескольких значений

Go способен возвращать несколько значений из функции:

.play src/func/multireturn/main.go

Для этого необходимы три вещи: указать несколько типов возвращаемых значений, разделенных ,, изменить выражение после return так, чтобы оно содержало несколько значений, разделенных запятой, и, наконец, изменить конструкцию присвоения так, чтобы она содержала несколько значений в левой части перед := или =.

* Переменное число аргументов функции
Существует особая форма записи последнего аргумента в функции Go:

.play src/func/multiarg/main.go

Использование ... перед типом последнего аргумента означает, что функция может содержать ноль и более таких параметров. В нашем случае мы берем ноль и более int. Функцию можно вызывать, как и раньше, но при этом ей можно передать любое количество аргументов типа int.

* Переменное число аргументов функции

Мы также можем передать срез int-ов, указав ... после среза:

.play src/func/multiarg/second/main.go

* Замыкания

Возможно создавать функции внутри функций:

.play src/func/closures/first/main.go

add является локальной переменной типа func(int, int) int (функция принимает два аргумента типа int и возвращает int). При создании локальная функция также получает доступ к локальным переменным (вспомните области видимости из главы 4):

* Замыкания

.play src/func/closures/second/main.go

increment прибавляет 1 к переменной x, которая определена в рамках функции main. Значение переменной x может быть изменено в функции increment. Вот почему при первом вызове increment на экран выводится 1, а при втором — 2.

Функцию, использующую переменные, определенные вне этой функции, называют замыканием.


* Генерация последовательностей

Один из способов использования замыкания — функция, возвращающая другую функцию, которая при вызове генерирует некую последовательность чисел. Например, следующим образом мы могли бы сгенерировать все четные числа:

.play src/func/closures/third/main.go

* Рекурсия

Наконец, функция может вызывать саму себя. Вот один из способов вычисления факториала числа:

.play src/func/recursion/first/main.go

* Рекурсия 

factorial вызывает саму себя, что делает эту функцию рекурсивной. Для того, чтобы лучше понять, как работает эта функция, давайте пройдемся по factorial(2):

- x == 0? Нет. (x равен 2);
- ищем факториал от x - 1;
- x == 0? Нет. (x равен 1);
- ищем факториал от 0;
- x == 0? Да, возвращаем 1;
- возвращаем 1 * 1;
- возвращаем 2 * 1.

* Рекурсия
Вы, наверное, уже заметили сходство понятий рекурсии и математической индукции. У рекурсии, как и у математической индукции, есть *база* — аргументы, для которых значения функции определены (элементарные задачи), и шаг рекурсии — способ сведения задачи к более простым.

.play src/func/recursion/second/main.go


* Рекурсия

.image img/recursion.png 550 _

* Отложенный вызов

В Go есть специальный оператор defer, который позволяет отложить вызов указанной функции до тех пор, пока не завершится текущая. Рассмотрим следующий пример:

.play src/func/defer/first/main.go

* defer

defer часто используется в случаях, когда нужно освободить ресурсы после завершения. Например, открывая файл необходимо убедиться, что позже он должен быть закрыт. C defer это выглядит так:

    f, _ := os.Open(filename)
    defer f.Close()

Такой подход дает нам три преимущества: (1) вызовы Close и Open располагаются рядом, что облегчает понимание программы, (2) если функция содержит несколько операций возврата (например, одна произойдет в блоке if, другая в блоке else), Close будет вызван до выхода из функции, (3) отложенные функции вызываются, даже если во время выполнения происходит ошибка.

* Паника и восстановление

Мы можем вызывать panic, чтобы сгенерировать ошибку выполнения. Мы можем обрабатывать паники с помощью встроенной функции recover. Функция recover останавливает панику и возвращает значение, которое было передано функции panic. Можно попытаться использовать recover следующим образом:

.play src/func/panic/first/main.go

Но в данном случае recover никогда не будет вызвана, поскольку вызов panic немедленно останавливает выполнение функции.

* Восстановление

Вместо этого мы должны использовать его вместе с defer:

.play src/func/panic/second/main.go

Паника обычно указывает на ошибку программиста (например, попытку получить доступ к несуществующему индексу массива, забытая и непроинициализированная карта и т.д.) или неожиданное поведение (исключение), которое нельзя обработать (поэтому оно и называется «паника»).


* Указатели

* Указатели

Когда мы вызываем функцию с аргументами, аргументы копируются в функцию:

.play src/pointers/first/main.go

В этой программе функция zero не изменяет оригинальную переменную x из функции main.

* Указатели

Но что если мы хотим её изменить? Один из способов сделать это — использовать специальный тип данных — указатель:

.play src/pointers/second/main.go

Указатели указывают (прошу прощения за тавтологию) на участок в памяти, где хранится значение. Используя указатель (*int) в функции zero, мы можем изменить значение оригинальной переменной.

* Операторы * и &

В Go указатели представлены через оператор * (звёздочка), за которым следует тип хранимого значения. В функции zero xPtr является указателем на int.

Символ * также используется для «разыменовывания» указателей. Когда мы пишем *xPtr = 0, то читаем это так: «Храним int 0 в памяти, на которую указывает xPtr». Если вместо этого мы попробуем написать xPtr = 0, то получим ошибку компиляции, потому что xPtr имеет тип не int, а *int. Соответственно, ему может быть присвоен только другой *int.

Также существует оператор &, который используется для получения адреса переменной. &x вернет *int (указатель на int) потому что x имеет тип int. Теперь мы можем изменять оригинальную переменную. &x в функции main и xPtr в функции zero указывают на один и тот же участок в памяти.

* Указатели

.play src/pointers/third/main.go

* Функция new

Другой способ получить указатель — использовать встроенную функцию new:

.play src/pointers/new/main.go

* Функция new

Функция new принимает аргументом тип, выделяет для него память и возвращает указатель на эту память.

В некоторых языках программирования есть существенная разница между использованием new и &, и в них нужно удалять всё, что было создано с помощью new. Go не такой - Go хороший. Go — язык с автоматической сборкой мусора. Это означает, что область памяти очищается автоматически, когда на неё не остаётся ссылок.

Указатели редко используются в Go для встроенных типов, но они будут часто фигурировать в следующей главе (они чрезвычайно полезны при работе со структурами).

* Задачка

Написать функцию-калькулятор, которая принимает операцию и возвращает функцию, выполняющую эту операцию

    func calc(operation string) func(a, b float64) float64

.link https://play.golang.org/p/G6YMZMHnotU https://play.golang.org/p/G6YMZMHnotU
.image img/qrcode.svg 400 _


* Задачка*
Написать функцию, которая возвращает функцию, выдающую значение полиномиальной математической функции на точке

    func polynomial(polynom []float64) func(x float64) float64

.image img/formula.svg _ 700
.link https://play.golang.org/p/wpefmNMZQWL https://play.golang.org/p/wpefmNMZQWL
.image img/qrcode-2.svg 250 _

* Форма для решений

.link https://forms.gle/AcUQ9zH3BPtPoLoN6 https://forms.gle/AcUQ9zH3BPtPoLoN6
.image img/qrcode-3.svg 500 _
